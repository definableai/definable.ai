---
title: Memory Stores
sidebarTitle: Stores
description: Storage backends for persistent agent memory.
icon: database
---

A `MemoryStore` is the storage backend for `Memory`. Definable provides three built-in implementations, from ephemeral in-memory stores for testing to production-grade PostgreSQL.

## Available Backends

| Backend | Import | Dependency | Best For |
|---------|--------|------------|----------|
| `InMemoryStore` | `definable.memory` | None | Testing, ephemeral sessions |
| `SQLiteStore` | `definable.memory` | `aiosqlite` (core) | Local dev, single-process |
| `PostgresStore` | `definable.memory` | `asyncpg` | Production, multi-process |

## Installation

The InMemory store requires no extra dependencies. SQLite uses `aiosqlite` (included as a core dependency). For PostgreSQL:

```bash
pip install 'definable[postgres-memory]'   # asyncpg
```

## Backend Examples

### InMemoryStore

Ephemeral store for testing. Data is lost when the process exits.

```python
from definable.memory import Memory, InMemoryStore

memory = Memory(store=InMemoryStore())
```

This is also what you get with `memory=True` on an Agent or when you omit the `store` parameter:

```python
from definable.agent import Agent
from definable.model.openai import OpenAIChat

# Both of these use InMemoryStore:
agent = Agent(model=OpenAIChat(id="gpt-4o"), memory=True)
agent = Agent(model=OpenAIChat(id="gpt-4o"), memory=Memory())
```

### SQLiteStore

The default choice for local development. Uses `aiosqlite` (included as a core dependency). Tables are auto-created on first use.

```python
from definable.memory import Memory, SQLiteStore

memory = Memory(store=SQLiteStore("./memory.db"))
```

<ParamField path="db_path" type="str" default="./memory.db">
  Path to the SQLite database file. Created automatically if it does not exist.
</ParamField>

### PostgresStore

Production-ready backend with connection pooling. Requires a running PostgreSQL instance.

```python
from definable.memory import Memory
from definable.memory.store.postgres import PostgresStore

memory = Memory(
  store=PostgresStore(
    db_url="postgresql://user:pass@localhost:5432/mydb",
    pool_size=5,
    table_prefix="memory_",
  )
)
```

<ParamField path="db_url" type="str" default="">
  PostgreSQL connection URL. Falls back to the `MEMORY_POSTGRES_URL` environment variable if not provided.
</ParamField>

<ParamField path="pool_size" type="int" default={5}>
  Connection pool size.
</ParamField>

<ParamField path="table_prefix" type="str" default="memory_">
  Prefix for database table names (e.g., `memory_memories`).
</ParamField>

## MemoryStore Protocol

All backends implement the `MemoryStore` protocol. You can create custom stores by implementing these seven methods:

```python
from definable.memory.store.base import MemoryStore
from definable.memory.types import UserMemory

class MyStore:
  async def initialize(self) -> None:
    """Prepare the store (create tables, open connections)."""
    ...

  async def close(self) -> None:
    """Release resources (close connections, flush buffers)."""
    ...

  async def get_user_memory(
    self,
    memory_id: str,
    user_id: str | None = None,
  ) -> UserMemory | None:
    """Retrieve a single memory by ID."""
    ...

  async def get_user_memories(
    self,
    user_id: str | None = None,
    agent_id: str | None = None,
    topics: list[str] | None = None,
    limit: int | None = None,
  ) -> list[UserMemory]:
    """Retrieve memories with optional filters, ordered by updated_at descending."""
    ...

  async def upsert_user_memory(self, memory: UserMemory) -> None:
    """Insert or update a memory. If a memory with the same memory_id exists, replace it."""
    ...

  async def delete_user_memory(
    self,
    memory_id: str,
    user_id: str | None = None,
  ) -> None:
    """Delete a single memory by ID."""
    ...

  async def clear_user_memories(self, user_id: str | None = None) -> None:
    """Delete all memories for a user. If user_id is None, delete ALL memories."""
    ...
```

All stores also support `async with` (async context manager) for automatic initialization and cleanup:

```python
async with SQLiteStore("./memory.db") as store:
  memories = await store.get_user_memories(user_id="alice")
```

### Method Reference

| Method | Description |
|--------|-------------|
| `initialize()` | Prepare the store (create tables, open connections). Called automatically by `Memory` on first use. |
| `close()` | Release resources. Called by `Memory.close()` or the agent's shutdown. |
| `get_user_memory(memory_id, user_id=)` | Fetch a single memory by its UUID. Returns `None` if not found. |
| `get_user_memories(user_id=, agent_id=, topics=, limit=)` | List memories with optional filters, ordered by most recently updated. |
| `upsert_user_memory(memory)` | Insert or replace a `UserMemory`. Automatically updates `updated_at`. |
| `delete_user_memory(memory_id, user_id=)` | Delete a single memory. The `user_id` parameter adds a safety scope. |
| `clear_user_memories(user_id=)` | Delete all memories for a user, or all memories if `user_id` is `None`. |

### Filter Parameters

The `get_user_memories()` method supports several filters:

| Parameter | Type | Description |
|-----------|------|-------------|
| `user_id` | `str \| None` | Only return memories for this user |
| `agent_id` | `str \| None` | Only return memories created by this agent |
| `topics` | `list[str] \| None` | Only return memories matching any of these topics |
| `limit` | `int \| None` | Maximum number of memories to return |

## UserMemory Data Type

Every store works with `UserMemory` objects:

| Field | Type | Default | Description |
|-------|------|---------|-------------|
| `memory` | `str` | â€” | The memory content (natural language fact) |
| `memory_id` | `str` | Auto-generated UUID | Unique identifier |
| `topics` | `list[str]` | `[]` | Topic tags for filtering |
| `user_id` | `str \| None` | `None` | User this memory belongs to |
| `agent_id` | `str \| None` | `None` | Agent that created this memory |
| `input` | `str \| None` | `None` | Original user message that triggered this memory |
| `created_at` | `float` | Auto-set | Unix timestamp |
| `updated_at` | `float` | Auto-set | Unix timestamp |

```python
from definable.memory.types import UserMemory

mem = UserMemory(
  memory="Alice works at Acme Corp as a Senior Engineer",
  topics=["work", "personal"],
  user_id="alice",
)

# Serialize / deserialize
data = mem.to_dict()
restored = UserMemory.from_dict(data)
```

## Choosing a Backend

| Scenario | Recommended Store |
|----------|-------------------|
| Unit tests, quick prototyping | `InMemoryStore` |
| Local development, single-process apps | `SQLiteStore` |
| Production, multi-process, horizontal scaling | `PostgresStore` |

For most projects, start with `SQLiteStore` during development and switch to `PostgresStore` for production. The store is a constructor parameter, so swapping backends requires changing a single line:

```python
# Development
memory = Memory(store=SQLiteStore("./memory.db"))

# Production
memory = Memory(store=PostgresStore(db_url=os.environ["DATABASE_URL"]))
```
